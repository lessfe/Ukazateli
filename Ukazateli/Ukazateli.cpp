#include <iostream>
#include <stdio.h>
#include <string>
using namespace std;
#define SIZE 5

void swap_1(int *d1, int *d2)
{
	//int* d1 = &d1;
	int tmp = *d1; //  d1 = 2;
	*d1 = *d2; // d1 = 11
	*d2 = tmp; // d2 = 2;

	cout << *d1 << "   " << *d2;
}

void swap_2(void (*p)(int*, int*), int* d1, int* d2)
{
	// void (*swap_1)
	// swap_1(d1, d2);
	p(d1, d2);

}

int str_len1(char* s)
{
	int i;

	for (i = 0; i < *(s+i) != '\0'; i++)
	{
		/*cout << *(s + i);*/
	}

	return i;
}

void print_arr(int* arr, int size)
{
	int* p = arr + size;
		for (; arr < p; arr++)
		
			cout << *arr;
		
}

void pluss(int* a, int* b)
{
	*a += *b;
}

void minuss(int* a, int* b)
{
	*a -= *b;
}

struct channel 
{
	char name[100];
	int subs;

};

int main()
{
	/*
	----------Бестиповый указатель void* ----------
	1) Может хранить адрес любой переменной или объекта.

	int d = 10;
	char c = 'G';
	float f = 2.3;

	void* pointer;
	pointer = &d;
	pointer = &c;
	pointer = &f;

	2) Но для выовода значения такого указателя нельзя просто применить разыменование, т.к. будет ошибка.
	Чтобы получить значение на которое указывает бестиповый указатеь нужно перед разыменованием явно привести его к указателю на нужный нам тип.
	Допустим, нужно вывести значение d типа int:

	int d = 10;
	void* pointer;
	pointer = &d;
	cout <<  *(int*) pointer;

	Приводим pointer к указателю на int и выведем его значение через разыменование.


	*/


	/*
				----------Аримфметика указателей----------
		1) Если a это указатель на какую - то ячейку в памяти, 
		то a + I это указатель на i - ую ячейку после той на которую указывает a.

		int arr[5] = { 1,2,3,4,5 };
		int* a = arr;
		cout << a + 1;

		2) Мы можем присваивать указателям значения других указателей одного типа.
		3) Мы можем сравнивать два указателя, которые указывают на элементы одного и того же массива.
		4) Если от одного указателя на эл-т массива отнять второй указ-ль на элемент того же массива, 
		то в рез-те получим кол-ов эл-ов между этими указателями.

		int arr[5] = { 1,2,3,4,5 };
		int* a = arr + 1;
		int* b = arr + 3;

		int dif = b - a;

		cout << dif;

		5) В арифметике мы можем использовать указатель на первый не существующий эл-т массива.
			Пример: функция print_arr, выводящая на экран все эл-ы массива.

			int arr[SIZE] = { 1,2,3,4,5};
			print_arr(arr, SIZE);

		6) Если два указателя, хранят адреса ячеек одного массива, то мы можем вычитать из одного указателя другой.

	*/

	/*
	char str[] = "HELLOWORLD";
	cout << "Length = " << str_len1(str);
	*/

	/*
	int num = 116;

	int* p_num = &num;

	*/
	
	/*	
		---------Разыменование указателя и присвание нового значения---------

	*p_num = 1000;

	*/

	/*	
		--------Вывод значение переменной через операцию разыменования--------

	cout << *p_num;

	*/

	/*
		--------Вывод адреса ячейки переменной--------

	cout << p_num;

	*/

	/*
		---------Создадим новую функцию, которая будем менять значения переменных.
	Если в качестве аргумента при вызове функции передавать просто переменные d1, d2, то в теле функции мы будем работать с 
	их "копиями". И поэтому функция не будет выполнять своего назначения.

	int d1 = 2, d2 = 11;
	swap_1(&d1, &d2);
	cout << d1 << "|" << d2;

	*/
	
	/*
	-----Имя массива - это указатель на его первый элемент, проверим это, выведя в консоль его разыменованый указатель--------
	
	short arr[5] = { 1, 2, 3, 4, 5 };
	short* parr = arr;

	*/

	/*
		---------Создадим новый указатель, который будет указывать на имя масссива--------
	Соответсвеннго, новому указателю мы присвоили значение первого элемента массива
	Можно это проверить.

	short* parr = arr;
	cout << *parr;

	*/

	/*
		--------Если arr  это имя массива, то arr + i это указатель на i - ый элемент массива. Поэтому, 
			чтобы вывести какой - то элемент массива можно сделать следующее :

	cout << *(arr + 1);

	*/

	/*
		--------Так как указатель – это переменная, то для него допустимы операции--------

	parr++; parr = arr;

	*/

	/*
		---------Но с именем массива так сделать нельзя---------

							arr = parr;
							arr++;

	*/
	
	/*
	Разница между строкой и указателем на строку
	Строковые константы это массивы символов, которые заканчиваются '\0';
	
	char s[] = "string"; // s - это сам массив
	const char* p = "pointer on string"; // p указывает на первый элемент строки, а s - это сам массив
	cout << s;	

	*/

	/*
			Группировка указателей в массивы
	Так как указатель – это переменная(их мы можем группировать в массивы), то мы можем их группировать также в массивы.

	
	double x1 = 2.1, x2 = 2.2, x3 = 2.3;
	double* p_arr[] = { &x1, &x2, &x3 };
	
			Двойная рызменовка
	Так как имя массива - это указатель на его первый элемент, то первой разыменовкой мы получаем доступ к его первому элементу, 
	а первый элемент - это также указатель. Поэтому для получения доступа к значению элемента массива нужна **
	Выведим таким образом второй элемент массива

	cout << **(p_arr + 1);
	
	*/
	
	/*
	Задание: создать массив указателей на строки и любым способом вывести их на экран

		Решение:
	
	const char* str1[] = { "String One", "String Two", "String Tree" };
	int size = sizeof(str1) / sizeof(str1[0]);
	for (int i = 0; i < size; i++)
	{
		cout << *(str1 + i);
	}

	const char str[][12] = { "String One", "String Two", "String Tree" };
	cout << sizeof(str[0]);
	*/

	/*
		Тоже самое с целочисленными массивами :

	int arr1[] = { 1, 3, 4, 6, 9};
	int arr2[] = { 1, 3, 4};
	int arr3[] = { 10};
	
	int* numbers[] = { arr1, arr2, arr3};
	
	Под такой массив указателей будет выделено 12 байт памяти.

	int numbers1[][5] = {
		{ 1, 3, 4, 6, 9},
		{ 1, 3, 4},
		{ 10}
	};

	А под такой уже 60. Первый элемент будет весить 5 * 4 байт, второй и третий столько же.
	Хотя, если записать каждый такой элемент в отдельный массив, то на первый выделится 20 байт, на второй 12 байт, на третий 4, что явно меньше 60.

	В случае с массивом указателей, у нас каждый элемент массива указателя – это указатель, 
	а в случае с двумерным массивом, каждый элемент – это отдельный элемент.

	*/

	/*Указатель на функцию
		Имя функции - это самой простой указатель на нее.

		Создадим указатель на функцию swap_1 по след.схеме: тип(*имя)(параметры);
		
		Первый способ вызова функции :

		void(*p_swap_1)(int* d1, int* d2) = swap_1;

		Здесь, скобки перед p_swap_1 также важны, т.к. без них:

		void* p_swap_1(int* d1, int* d2) = swap_1;
		p_swap_1 будет функцией, которая возращает указатель типа void


		int d1 = 6;
		int d2 = 8;
		p_swap_1(&d1, &d2);

		Второй способ вызова функции :
		Если p_swap_1 - это указатель на функцию swap_1, то разыменовав указатель на функцию, мы получим доступ к самой функции.
		(*p_swap_1)(&d1, &d2);	
		Скобки перед p_swap_1 необходимы, т.к. вызов функции имеет высший приоритет.

		
		int d1 = 6; // d1 = -2;	
		int d2 = 8; // d2 = 8
		void (*p_arrays[])(int*, int*) = { minuss, pluss};

		for (int i = 0; i < 2; i++)
		{
			p_arrays[i](&d1, &d2);
			cout << d1 << endl << d2 << endl;
		}
		p_arrays[0](&d1, &d2);

		cout << d1 << endl << d2;
		

		Указатель функции можно передать, как аргумент другой функции.
		int d1 = 6; // d1 = -2;	
		int d2 = 8;
		swap_2(swap_1, &d1, &d2);
		*/

	struct channel GOALACTION = { "GOALACTION", 126 };
	struct channel* p1 = &GOALACTION;


}

